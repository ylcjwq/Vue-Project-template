"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAPIGenerator = void 0;
exports.generateAPI = generateAPI;
exports.viteOpenAPIGenerator = viteOpenAPIGenerator;
const fs = __importStar(require("node:fs"));
const path = __importStar(require("node:path"));
/**
 * 创建一个 OpenAPI Generator 实例并生成 API 文件
 * @param options 生成器配置选项
 */
async function generateAPI(options) {
    const generator = new OpenAPIGenerator(options.outputDir);
    await generator.generateFromFile(options.openapiPath);
}
/**
 * OpenAPI生成器类
 * 负责从OpenAPI文档生成TypeScript API客户端代码
 */
class OpenAPIGenerator {
    /**
     * 构造函数
     * @param apiDir API输出目录
     */
    constructor(apiDir) {
        /** 类型缓存，用于存储已生成的类型定义 */
        this.typeCache = new Map();
        this.apiDir = apiDir;
    }
    /**
     * 从文件加载OpenAPI文档并生成API
     * @param filePath OpenAPI文档文件路径
     */
    async generateFromFile(filePath) {
        const content = await fs.promises.readFile(filePath, 'utf-8');
        this.document = JSON.parse(content);
        await this.generate();
    }
    /**
     * 从 OpenAPI 文档字符串生成 API 文件
     * @param content OpenAPI文档内容字符串
     */
    async generateFromString(content) {
        this.document = JSON.parse(content);
        await this.generate();
    }
    /**
     * 生成API文件的主方法
     * 按标签分组生成接口文件
     */
    async generate() {
        // 确保 api 目录存在
        if (!fs.existsSync(this.apiDir)) {
            fs.mkdirSync(this.apiDir, { recursive: true });
        }
        // 按 tag 分组生成接口文件
        const tags = this.document.tags || [];
        for (const tag of tags) {
            const tagName = tag.name;
            const operations = this.getOperationsByTag(tagName);
            console.log(tag, operations);
            if (operations.length > 0) {
                await this.generateTagFile(tagName, operations);
            }
        }
    }
    /**
     * 获取指定标签下的所有操作
     * @param tagName 标签名称
     * @returns 操作数组，包含路径、方法和操作对象
     */
    getOperationsByTag(tagName) {
        const operations = [];
        for (const [path, methods] of Object.entries(this.document.paths)) {
            for (const [method, operation] of Object.entries(methods)) {
                if (operation.tags?.includes(tagName)) {
                    operations.push({ path, method, operation });
                }
            }
        }
        return operations;
    }
    /**
     * 为指定标签生成API文件
     * @param tagName 标签名称
     * @param operations 操作数组
     */
    async generateTagFile(tagName, operations) {
        const filePath = path.join(this.apiDir, `${tagName}.ts`);
        let content = '// Auto-generated by OpenAPI Generator\n\n';
        // 添加类型定义
        content += this.generateTypeDefinitions(operations);
        console.log(content, '类型定义content');
        // 添加接口定义
        // content += this.generateInterfaceDefinitions(operations);
        // console.log(content, '接口定义content');
        // 添加请求函数
        content += this.generateRequestFunctions(operations);
        console.log(content, '请求函数content');
        await fs.promises.writeFile(filePath, content, 'utf-8');
    }
    /**
     * 生成类型定义
     * @param operations 操作数组
     * @returns 类型定义字符串
     */
    generateTypeDefinitions(operations) {
        let content = '// Type Definitions\n';
        // 收集所有需要的类型
        const types = new Set();
        for (const { operation } of operations) {
            // 收集请求体类型
            if (operation.requestBody) {
                const schema = operation.requestBody.content['application/json']?.schema;
                if (schema && this.isSchemaObject(schema)) {
                    types.add(this.getTypeName(schema));
                }
            }
            // 收集响应类型
            for (const response of Object.values(operation.responses)) {
                const schema = response.content?.['application/json']?.schema;
                if (schema && this.isSchemaObject(schema)) {
                    types.add(this.getTypeName(schema));
                }
            }
        }
        // 生成类型定义
        for (const type of types) {
            content += `export interface ${type} {\n`;
            const schema = this.typeCache.get(type);
            if (schema) {
                content += this.generateTypeProperties(JSON.parse(schema));
            }
            content += '}\n\n';
        }
        return content;
    }
    /**
     * 生成类型属性
     * @param schema Schema对象
     * @returns 属性定义字符串
     */
    generateTypeProperties(schema) {
        let content = '';
        if (schema.properties) {
            for (const [name, prop] of Object.entries(schema.properties)) {
                if (this.isSchemaObject(prop)) {
                    const type = this.getTypeName(prop);
                    const required = schema.required?.includes(name) ?? false;
                    content += `  ${name}${required ? '' : '?'}: ${type};\n`;
                }
            }
        }
        return content;
    }
    /**
     * 获取操作的路径参数
     * @param operation 操作对象
     * @returns 路径参数数组
     */
    getPathParameters(operation) {
        const parameters = [];
        if (operation.parameters) {
            for (const param of operation.parameters) {
                if (this.isParameterObject(param)) {
                    if (param.in === 'path' || param.in === 'query' || param.in === 'header') {
                        parameters.push({
                            name: param.name,
                            in: param.in,
                            required: param.required ?? false,
                            schema: param.schema,
                        });
                    }
                }
            }
        }
        return parameters;
    }
    /**
     * 判断参数是否为ParameterObject而非ReferenceObject
     * @param param 参数对象
     * @returns 是否为ParameterObject
     */
    isParameterObject(param) {
        return !('$ref' in param);
    }
    /**
     * 生成接口定义
     * @param operations 操作数组
     * @returns 接口定义字符串
     */
    generateInterfaceDefinitions(operations) {
        let content = '// Interface Definitions\n';
        for (const { operation } of operations) {
            const interfaceName = this.getInterfaceName(operation);
            console.log(interfaceName, 'interfaceName');
            content += `export interface ${interfaceName} {\n`;
            // 添加路径参数、查询参数和请求头
            const parameters = this.getPathParameters(operation);
            console.log(parameters, 'parameters');
            console.log(content, 'content');
            if (parameters.length > 0) {
                content += '  params: {\n';
                console.log(content, 'content');
                for (const param of parameters) {
                    const type = this.getTypeName(param.schema);
                    content += `    ${param.name}${param.required ? '' : '?'}: ${type};\n`;
                    console.log(content, 'content');
                }
                content += '  };\n';
                console.log(content, 'content');
            }
            // 添加请求体类型
            if (operation.requestBody) {
                const schema = operation.requestBody.content['application/json']?.schema;
                if (schema && this.isSchemaObject(schema)) {
                    content += `  request: ${this.getTypeName(schema)};\n`;
                }
            }
            // 添加响应类型
            const successResponse = operation.responses['200'] || operation.responses['201'];
            if (successResponse) {
                const schema = successResponse.content?.['application/json']
                    ?.schema;
                if (schema && this.isSchemaObject(schema)) {
                    content += `  response: ${this.getTypeName(schema)};\n`;
                }
            }
            // 添加错误类型
            const errorResponses = Object.entries(operation.responses)
                .filter(([status]) => status.startsWith('4') || status.startsWith('5'))
                .map(([_, response]) => response);
            if (errorResponses.length > 0) {
                content += '  error: {\n';
                for (const response of errorResponses) {
                    const schema = response.content?.['application/json']?.schema;
                    if (schema && this.isSchemaObject(schema)) {
                        content += `    ${this.getTypeName(schema)};\n`;
                    }
                }
                content += '  };\n';
            }
            content += '}\n\n';
        }
        return content;
    }
    /**
     * 生成请求函数
     * @param operations 操作数组
     * @returns 请求函数字符串
     */
    generateRequestFunctions(operations) {
        let content = '// Request Functions\n';
        console.log(operations, 'operations');
        for (const { path, method, operation } of operations) {
            const functionName = this.getFunctionName(operation, path, method);
            const parameters = this.getPathParameters(operation);
            // 生成函数注释
            content += this.generateFunctionComment(operation, path, method);
            // 确定函数签名
            let functionSignature = `export async function ${functionName}(`;
            const hasParams = parameters.length > 0;
            const hasRequestBody = !!operation.requestBody;
            // 添加参数
            if (hasParams) {
                functionSignature += `params: {
${parameters
                    .map((param) => `    ${param.name}${param.required ? '' : '?'}: ${this.getTypeName(param.schema)}`)
                    .join(';\n')};
  }`;
            }
            // 添加请求体
            if (hasRequestBody) {
                const schema = operation.requestBody.content['application/json']?.schema;
                if (schema && this.isSchemaObject(schema)) {
                    const requestType = this.getTypeName(schema);
                    if (hasParams) {
                        functionSignature += ', ';
                    }
                    functionSignature += `body: ${requestType}`;
                }
            }
            // 添加返回类型
            const successResponse = operation.responses['200'] || operation.responses['201'];
            let responseType = 'any';
            if (successResponse) {
                const schema = successResponse.content?.['application/json']
                    ?.schema;
                if (schema && this.isSchemaObject(schema)) {
                    responseType = this.getTypeName(schema);
                }
            }
            functionSignature += `): Promise<${responseType}> {\n`;
            content += functionSignature;
            // 处理路径参数
            let url = path;
            for (const param of parameters) {
                if (param.in === 'path') {
                    url = url.replace(`{${param.name}}`, `\${params.${param.name}}`);
                }
            }
            // 处理查询参数
            const queryParams = parameters.filter((p) => p.in === 'query');
            if (queryParams.length > 0) {
                url += '?';
                url += queryParams.map((p) => `${p.name}=\${params.${p.name}}`).join('&');
            }
            // 处理请求头
            const headers = {
                'Content-Type': 'application/json',
            };
            const headerParams = parameters.filter((p) => p.in === 'header');
            for (const param of headerParams) {
                headers[param.name] = `\${params.${param.name}}`;
            }
            content += `  const response = await fetch(\`${url}\`, {\n`;
            content += `    method: '${method.toUpperCase()}',\n`;
            content += '    headers: {\n';
            for (const [name, value] of Object.entries(headers)) {
                content += `      '${name}': '${value}',\n`;
            }
            content += '    },\n';
            // 只有在有请求体时才添加body属性
            if (hasRequestBody) {
                content += '    body: JSON.stringify(body),\n';
            }
            content += '  });\n\n';
            content += '  if (!response.ok) {\n';
            content += '    const error = await response.json() as ApiError;\n';
            content +=
                // eslint-disable-next-line no-template-curly-in-string
                '    throw new Error(`HTTP error! status: ${response.status}, message: ${error.message}`);\n';
            content += '  }\n\n';
            content += '  return response.json();\n';
            content += '}\n\n';
        }
        return content;
    }
    /**
     * 为函数生成详细注释
     * @param operation 操作对象
     * @param path API路径
     * @param method HTTP方法
     * @returns 函数注释字符串
     */
    generateFunctionComment(operation, path, method) {
        let comment = '/**\n';
        // 添加函数描述
        comment += ` * ${operation.summary || '无描述'}\n`;
        if (operation.description) {
            comment += ` * ${operation.description}\n`;
        }
        comment += ` *\n`;
        // 添加请求方法和路径
        comment += ` * @method ${method.toUpperCase()}\n`;
        comment += ` * @path ${path}\n`;
        comment += ` *\n`;
        // 添加参数说明
        if (operation.parameters && operation.parameters.length > 0) {
            for (const param of operation.parameters) {
                if (this.isParameterObject(param)) {
                    comment += ` * @param {${param.schema ? this.getTypeName(param.schema) : 'any'}} ${param.name} ${param.description || ''} ${param.required ? '(必需)' : '(可选)'}\n`;
                }
            }
        }
        // 添加请求体说明
        if (operation.requestBody) {
            const requestBody = operation.requestBody;
            const schema = requestBody.content?.['application/json']?.schema;
            if (schema && this.isSchemaObject(schema)) {
                comment += ` * @param {${this.getTypeName(schema)}} body ${requestBody.description || '请求体'}\n`;
            }
        }
        // 添加响应说明
        if (operation.responses) {
            comment += ` *\n`;
            comment += ` * @returns {Promise<any>} 响应数据\n`;
            for (const [status, response] of Object.entries(operation.responses)) {
                if (this.isResponseObject(response)) {
                    comment += ` * @response ${status} ${response.description || '无描述'}\n`;
                }
            }
        }
        comment += ` */\n`;
        return comment;
    }
    /**
     * 判断响应是否为ResponseObject而非ReferenceObject
     * @param response 响应对象
     * @returns 是否为ResponseObject
     */
    isResponseObject(response) {
        return !('$ref' in response);
    }
    /**
     * 判断schema是否为SchemaObject而非ReferenceObject
     * @param schema Schema对象
     * @returns 是否为SchemaObject
     */
    isSchemaObject(schema) {
        return !('$ref' in schema);
    }
    /**
     * 获取Schema对应的TypeScript类型名称
     * @param schema Schema对象
     * @returns TypeScript类型名称
     */
    getTypeName(schema) {
        if (schema.type === 'string') {
            return 'string';
        }
        if (schema.type === 'number' || schema.type === 'integer') {
            return 'number';
        }
        if (schema.type === 'boolean') {
            return 'boolean';
        }
        if (schema.type === 'array') {
            const items = schema.items;
            if (items && this.isSchemaObject(items)) {
                return `${this.getTypeName(items)}[]`;
            }
            return 'any[]';
        }
        if (schema.type === 'object' || schema.properties) {
            const typeName = this.generateTypeName(schema);
            this.typeCache.set(typeName, JSON.stringify(schema));
            return typeName;
        }
        return 'any';
    }
    /**
     * 根据Schema生成类型名称
     * @param schema Schema对象
     * @returns 生成的类型名称
     */
    generateTypeName(schema) {
        if (schema.title) {
            return schema.title;
        }
        if (schema.description) {
            return schema.description.split(' ')[0];
        }
        return 'UnknownType';
    }
    /**
     * 获取操作的接口名称
     * @param operation 操作对象
     * @returns 接口名称
     */
    getInterfaceName(operation) {
        return operation.operationId || operation.summary || 'Unknown';
    }
    /**
     * 获取操作的函数名称
     * @param operation 操作对象
     * @param path API路径
     * @param method HTTP方法
     * @returns 函数名称
     */
    getFunctionName(operation, path, method) {
        // 获取路径的所有部分
        const pathParts = path.split('/').filter(Boolean);
        // 查找最后一个有意义的路径部分（非变量部分）
        let meaningfulPart = '';
        for (let i = pathParts.length - 1; i >= 0; i--) {
            const part = pathParts[i];
            if (!part.startsWith('{') && !part.endsWith('}')) {
                // 找到了非变量部分
                meaningfulPart = part;
                break;
            }
            else if (i > 0) {
                // 如果最后部分是变量，且前面还有部分，取前一个部分
                const prevPart = pathParts[i - 1];
                if (!prevPart.startsWith('{') && !prevPart.endsWith('}')) {
                    meaningfulPart = prevPart;
                }
                break;
            }
        }
        // 如果找不到有意义的部分，使用operationId或fallback
        if (!meaningfulPart) {
            return operation.operationId || operation.summary || 'unknownAsync';
        }
        // 组合方法名：HTTP方法 + 路径部分 + async (小驼峰命名)
        const methodLower = method.toLowerCase();
        const pathPartCapitalized = meaningfulPart.charAt(0).toUpperCase() + meaningfulPart.slice(1);
        return `${methodLower}${pathPartCapitalized}Async`;
    }
}
exports.OpenAPIGenerator = OpenAPIGenerator;
/**
 * 为 Vite 创建的兼容插件（为了向后兼容）
 * @param options 生成器配置选项
 * @returns Vite插件对象
 */
function viteOpenAPIGenerator(options) {
    return {
        name: 'vite-plugin-openapi-generator',
        async buildStart() {
            await generateAPI(options);
        },
    };
}

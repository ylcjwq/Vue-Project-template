import * as fs from 'node:fs';
import * as path from 'node:path';
import type { OpenAPIV3 } from 'openapi-types';

/**
 * OpenAPI文档接口，扩展自OpenAPIV3.Document
 * 定义API路径和标签结构
 */
interface OpenAPIDocument extends OpenAPIV3.Document {
  paths: {
    [path: string]: {
      [method: string]: OpenAPIV3.OperationObject;
    };
  };
  tags?: OpenAPIV3.TagObject[];
}

/**
 * 路径参数接口
 * 用于定义API路径中的参数、查询参数或请求头
 */
interface PathParameter {
  name: string;
  in: 'path' | 'query' | 'header';
  required: boolean;
  schema: OpenAPIV3.SchemaObject;
}

/**
 * OpenAPI生成器配置选项
 */
interface OpenAPIGeneratorOptions {
  /**
   * OpenAPI 文档路径
   */
  openapiPath: string;
  /**
   * 生成的 API 文件输出目录
   */
  outputDir: string;
}

/**
 * 创建一个 OpenAPI Generator 实例并生成 API 文件
 * @param options 生成器配置选项
 */
export async function generateAPI(options: OpenAPIGeneratorOptions): Promise<void> {
  const generator = new OpenAPIGenerator(options.outputDir);
  await generator.generateFromFile(options.openapiPath);
}

/**
 * OpenAPI生成器类
 * 负责从OpenAPI文档生成TypeScript API客户端代码
 */
export class OpenAPIGenerator {
  /** API输出目录路径 */
  private apiDir: string;
  /** 解析后的OpenAPI文档 */
  private document!: OpenAPIDocument;
  /** 类型缓存，用于存储已生成的类型定义 */
  private typeCache: Map<string, string> = new Map();

  /**
   * 构造函数
   * @param apiDir API输出目录
   */
  constructor(apiDir: string) {
    this.apiDir = apiDir;
  }

  /**
   * 从文件加载OpenAPI文档并生成API
   * @param filePath OpenAPI文档文件路径
   */
  public async generateFromFile(filePath: string): Promise<void> {
    const content = await fs.promises.readFile(filePath, 'utf-8');
    this.document = JSON.parse(content) as OpenAPIDocument;
    await this.generate();
  }

  /**
   * 从 OpenAPI 文档字符串生成 API 文件
   * @param content OpenAPI文档内容字符串
   */
  public async generateFromString(content: string): Promise<void> {
    this.document = JSON.parse(content) as OpenAPIDocument;
    await this.generate();
  }

  /**
   * 生成API文件的主方法
   * 按标签分组生成接口文件
   */
  private async generate(): Promise<void> {
    // 确保 api 目录存在
    if (!fs.existsSync(this.apiDir)) {
      fs.mkdirSync(this.apiDir, { recursive: true });
    }

    // 按 tag 分组生成接口文件
    const tags = this.document.tags || [];
    for (const tag of tags) {
      const tagName = tag.name;
      const operations = this.getOperationsByTag(tagName);
      console.log(tag, operations);
      if (operations.length > 0) {
        await this.generateTagFile(tagName, operations);
      }
    }
  }

  /**
   * 获取指定标签下的所有操作
   * @param tagName 标签名称
   * @returns 操作数组，包含路径、方法和操作对象
   */
  private getOperationsByTag(tagName: string): Array<{
    path: string;
    method: string;
    operation: OpenAPIV3.OperationObject;
  }> {
    const operations: Array<{
      path: string;
      method: string;
      operation: OpenAPIV3.OperationObject;
    }> = [];
    for (const [path, methods] of Object.entries(this.document.paths)) {
      for (const [method, operation] of Object.entries(methods)) {
        if (operation.tags?.includes(tagName)) {
          operations.push({ path, method, operation });
        }
      }
    }
    return operations;
  }

  /**
   * 为指定标签生成API文件
   * @param tagName 标签名称
   * @param operations 操作数组
   */
  private async generateTagFile(
    tagName: string,
    operations: Array<{
      path: string;
      method: string;
      operation: OpenAPIV3.OperationObject;
    }>,
  ): Promise<void> {
    const filePath = path.join(this.apiDir, `${tagName}.ts`);
    let content = '// Auto-generated by OpenAPI Generator\n\n';

    // 添加类型定义
    content += this.generateTypeDefinitions(operations);
    console.log(content, '类型定义content');

    // 添加接口定义
    // content += this.generateInterfaceDefinitions(operations);
    // console.log(content, '接口定义content');

    // 添加请求函数
    content += this.generateRequestFunctions(operations);
    console.log(content, '请求函数content');

    await fs.promises.writeFile(filePath, content, 'utf-8');
  }

  /**
   * 生成类型定义
   * @param operations 操作数组
   * @returns 类型定义字符串
   */
  private generateTypeDefinitions(
    operations: Array<{
      path: string;
      method: string;
      operation: OpenAPIV3.OperationObject;
    }>,
  ): string {
    let content = '// Type Definitions\n';

    // 收集所有需要的类型
    const types = new Set<string>();
    for (const { operation } of operations) {
      // 收集请求体类型
      if (operation.requestBody) {
        const schema = (operation.requestBody as OpenAPIV3.RequestBodyObject).content[
          'application/json'
        ]?.schema;
        if (schema && this.isSchemaObject(schema)) {
          types.add(this.getTypeName(schema));
        }
      }

      // 收集响应类型
      for (const response of Object.values(operation.responses)) {
        const schema = (response as OpenAPIV3.ResponseObject).content?.['application/json']?.schema;
        if (schema && this.isSchemaObject(schema)) {
          types.add(this.getTypeName(schema));
        }
      }
    }

    // 生成类型定义
    for (const type of types) {
      content += `export interface ${type} {\n`;
      const schema = this.typeCache.get(type);
      if (schema) {
        content += this.generateTypeProperties(JSON.parse(schema));
      }
      content += '}\n\n';
    }

    return content;
  }

  /**
   * 生成类型属性
   * @param schema Schema对象
   * @returns 属性定义字符串
   */
  private generateTypeProperties(schema: OpenAPIV3.SchemaObject): string {
    let content = '';
    if (schema.properties) {
      for (const [name, prop] of Object.entries(schema.properties)) {
        if (this.isSchemaObject(prop)) {
          const type = this.getTypeName(prop);
          const required = schema.required?.includes(name) ?? false;
          content += `  ${name}${required ? '' : '?'}: ${type};\n`;
        }
      }
    }
    return content;
  }

  /**
   * 获取操作的路径参数
   * @param operation 操作对象
   * @returns 路径参数数组
   */
  private getPathParameters(operation: OpenAPIV3.OperationObject): PathParameter[] {
    const parameters: PathParameter[] = [];
    if (operation.parameters) {
      for (const param of operation.parameters) {
        if (this.isParameterObject(param)) {
          if (param.in === 'path' || param.in === 'query' || param.in === 'header') {
            parameters.push({
              name: param.name,
              in: param.in,
              required: param.required ?? false,
              schema: param.schema as OpenAPIV3.SchemaObject,
            });
          }
        }
      }
    }
    return parameters;
  }

  /**
   * 判断参数是否为ParameterObject而非ReferenceObject
   * @param param 参数对象
   * @returns 是否为ParameterObject
   */
  private isParameterObject(
    param: OpenAPIV3.ReferenceObject | OpenAPIV3.ParameterObject,
  ): param is OpenAPIV3.ParameterObject {
    return !('$ref' in param);
  }

  /**
   * 生成接口定义
   * @param operations 操作数组
   * @returns 接口定义字符串
   */
  private generateInterfaceDefinitions(
    operations: Array<{
      path: string;
      method: string;
      operation: OpenAPIV3.OperationObject;
    }>,
  ): string {
    let content = '// Interface Definitions\n';

    for (const { operation } of operations) {
      const interfaceName = this.getInterfaceName(operation);
      console.log(interfaceName, 'interfaceName');
      content += `export interface ${interfaceName} {\n`;

      // 添加路径参数、查询参数和请求头
      const parameters = this.getPathParameters(operation);
      console.log(parameters, 'parameters');
      console.log(content, 'content');
      if (parameters.length > 0) {
        content += '  params: {\n';
        console.log(content, 'content');
        for (const param of parameters) {
          const type = this.getTypeName(param.schema);
          content += `    ${param.name}${param.required ? '' : '?'}: ${type};\n`;
          console.log(content, 'content');
        }
        content += '  };\n';
        console.log(content, 'content');
      }

      // 添加请求体类型
      if (operation.requestBody) {
        const schema = (operation.requestBody as OpenAPIV3.RequestBodyObject).content[
          'application/json'
        ]?.schema;
        if (schema && this.isSchemaObject(schema)) {
          content += `  request: ${this.getTypeName(schema)};\n`;
        }
      }

      // 添加响应类型
      const successResponse = operation.responses['200'] || operation.responses['201'];
      if (successResponse) {
        const schema = (successResponse as OpenAPIV3.ResponseObject).content?.['application/json']
          ?.schema;
        if (schema && this.isSchemaObject(schema)) {
          content += `  response: ${this.getTypeName(schema)};\n`;
        }
      }

      // 添加错误类型
      const errorResponses = Object.entries(operation.responses)
        .filter(([status]) => status.startsWith('4') || status.startsWith('5'))
        .map(([_, response]) => response as OpenAPIV3.ResponseObject);
      if (errorResponses.length > 0) {
        content += '  error: {\n';
        for (const response of errorResponses) {
          const schema = response.content?.['application/json']?.schema;
          if (schema && this.isSchemaObject(schema)) {
            content += `    ${this.getTypeName(schema)};\n`;
          }
        }
        content += '  };\n';
      }

      content += '}\n\n';
    }

    return content;
  }

  /**
   * 生成请求函数
   * @param operations 操作数组
   * @returns 请求函数字符串
   */
  private generateRequestFunctions(
    operations: Array<{
      path: string;
      method: string;
      operation: OpenAPIV3.OperationObject;
    }>,
  ): string {
    let content = '// Request Functions\n';
    console.log(operations, 'operations');

    for (const { path, method, operation } of operations) {
      const functionName = this.getFunctionName(operation, path, method);
      const parameters = this.getPathParameters(operation);

      // 生成函数注释
      content += this.generateFunctionComment(operation, path, method);

      // 确定函数签名
      let functionSignature = `export async function ${functionName}(`;
      const hasParams = parameters.length > 0;
      const hasRequestBody = !!operation.requestBody;

      // 添加参数
      if (hasParams) {
        functionSignature += `params: {
${parameters
  .map(
    (param) => `    ${param.name}${param.required ? '' : '?'}: ${this.getTypeName(param.schema)}`,
  )
  .join(';\n')};
  }`;
      }

      // 添加请求体
      if (hasRequestBody) {
        const schema = (operation.requestBody as OpenAPIV3.RequestBodyObject).content[
          'application/json'
        ]?.schema;
        if (schema && this.isSchemaObject(schema)) {
          const requestType = this.getTypeName(schema);
          if (hasParams) {
            functionSignature += ', ';
          }
          functionSignature += `body: ${requestType}`;
        }
      }

      // 添加返回类型
      const successResponse = operation.responses['200'] || operation.responses['201'];
      let responseType = 'any';
      if (successResponse) {
        const schema = (successResponse as OpenAPIV3.ResponseObject).content?.['application/json']
          ?.schema;
        if (schema && this.isSchemaObject(schema)) {
          responseType = this.getTypeName(schema);
        }
      }
      functionSignature += `): Promise<${responseType}> {\n`;

      content += functionSignature;

      // 处理路径参数
      let url = path;
      for (const param of parameters) {
        if (param.in === 'path') {
          url = url.replace(`{${param.name}}`, `\${params.${param.name}}`);
        }
      }

      // 处理查询参数
      const queryParams = parameters.filter((p) => p.in === 'query');
      if (queryParams.length > 0) {
        url += '?';
        url += queryParams.map((p) => `${p.name}=\${params.${p.name}}`).join('&');
      }

      // 处理请求头
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };
      const headerParams = parameters.filter((p) => p.in === 'header');
      for (const param of headerParams) {
        headers[param.name] = `\${params.${param.name}}`;
      }

      content += `  const response = await fetch(\`${url}\`, {\n`;
      content += `    method: '${method.toUpperCase()}',\n`;
      content += '    headers: {\n';
      for (const [name, value] of Object.entries(headers)) {
        content += `      '${name}': '${value}',\n`;
      }
      content += '    },\n';

      // 只有在有请求体时才添加body属性
      if (hasRequestBody) {
        content += '    body: JSON.stringify(body),\n';
      }

      content += '  });\n\n';
      content += '  if (!response.ok) {\n';
      content += '    const error = await response.json() as ApiError;\n';
      content +=
        // eslint-disable-next-line no-template-curly-in-string
        '    throw new Error(`HTTP error! status: ${response.status}, message: ${error.message}`);\n';
      content += '  }\n\n';
      content += '  return response.json();\n';
      content += '}\n\n';
    }

    return content;
  }

  /**
   * 为函数生成详细注释
   * @param operation 操作对象
   * @param path API路径
   * @param method HTTP方法
   * @returns 函数注释字符串
   */
  private generateFunctionComment(
    operation: OpenAPIV3.OperationObject,
    path: string,
    method: string,
  ): string {
    let comment = '/**\n';

    // 添加函数描述
    comment += ` * ${operation.summary || '无描述'}\n`;
    if (operation.description) {
      comment += ` * ${operation.description}\n`;
    }
    comment += ` *\n`;

    // 添加请求方法和路径
    comment += ` * @method ${method.toUpperCase()}\n`;
    comment += ` * @path ${path}\n`;
    comment += ` *\n`;

    // 添加参数说明
    if (operation.parameters && operation.parameters.length > 0) {
      for (const param of operation.parameters) {
        if (this.isParameterObject(param)) {
          comment += ` * @param {${
            param.schema ? this.getTypeName(param.schema as OpenAPIV3.SchemaObject) : 'any'
          }} ${param.name} ${param.description || ''} ${param.required ? '(必需)' : '(可选)'}\n`;
        }
      }
    }

    // 添加请求体说明
    if (operation.requestBody) {
      const requestBody = operation.requestBody as OpenAPIV3.RequestBodyObject;
      const schema = requestBody.content?.['application/json']?.schema;
      if (schema && this.isSchemaObject(schema)) {
        comment += ` * @param {${this.getTypeName(schema)}} body ${
          requestBody.description || '请求体'
        }\n`;
      }
    }

    // 添加响应说明
    if (operation.responses) {
      comment += ` *\n`;
      comment += ` * @returns {Promise<any>} 响应数据\n`;

      for (const [status, response] of Object.entries(operation.responses)) {
        if (this.isResponseObject(response)) {
          comment += ` * @response ${status} ${response.description || '无描述'}\n`;
        }
      }
    }

    comment += ` */\n`;
    return comment;
  }

  /**
   * 判断响应是否为ResponseObject而非ReferenceObject
   * @param response 响应对象
   * @returns 是否为ResponseObject
   */
  private isResponseObject(
    response: OpenAPIV3.ReferenceObject | OpenAPIV3.ResponseObject,
  ): response is OpenAPIV3.ResponseObject {
    return !('$ref' in response);
  }

  /**
   * 判断schema是否为SchemaObject而非ReferenceObject
   * @param schema Schema对象
   * @returns 是否为SchemaObject
   */
  private isSchemaObject(
    schema: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject,
  ): schema is OpenAPIV3.SchemaObject {
    return !('$ref' in schema);
  }

  /**
   * 获取Schema对应的TypeScript类型名称
   * @param schema Schema对象
   * @returns TypeScript类型名称
   */
  private getTypeName(schema: OpenAPIV3.SchemaObject): string {
    if (schema.type === 'string') {
      return 'string';
    }
    if (schema.type === 'number' || schema.type === 'integer') {
      return 'number';
    }
    if (schema.type === 'boolean') {
      return 'boolean';
    }
    if (schema.type === 'array') {
      const items = schema.items;
      if (items && this.isSchemaObject(items)) {
        return `${this.getTypeName(items)}[]`;
      }
      return 'any[]';
    }
    if (schema.type === 'object' || schema.properties) {
      const typeName = this.generateTypeName(schema);
      this.typeCache.set(typeName, JSON.stringify(schema));
      return typeName;
    }
    return 'any';
  }

  /**
   * 根据Schema生成类型名称
   * @param schema Schema对象
   * @returns 生成的类型名称
   */
  private generateTypeName(schema: OpenAPIV3.SchemaObject): string {
    if (schema.title) {
      return schema.title;
    }
    if (schema.description) {
      return schema.description.split(' ')[0];
    }
    return 'UnknownType';
  }

  /**
   * 获取操作的接口名称
   * @param operation 操作对象
   * @returns 接口名称
   */
  private getInterfaceName(operation: OpenAPIV3.OperationObject): string {
    return operation.operationId || operation.summary || 'Unknown';
  }

  /**
   * 获取操作的函数名称
   * @param operation 操作对象
   * @param path API路径
   * @param method HTTP方法
   * @returns 函数名称
   */
  private getFunctionName(
    operation: OpenAPIV3.OperationObject,
    path: string,
    method: string,
  ): string {
    // 获取路径的所有部分
    const pathParts = path.split('/').filter(Boolean);

    // 查找最后一个有意义的路径部分（非变量部分）
    let meaningfulPart = '';
    for (let i = pathParts.length - 1; i >= 0; i--) {
      const part = pathParts[i];
      if (!part.startsWith('{') && !part.endsWith('}')) {
        // 找到了非变量部分
        meaningfulPart = part;
        break;
      } else if (i > 0) {
        // 如果最后部分是变量，且前面还有部分，取前一个部分
        const prevPart = pathParts[i - 1];
        if (!prevPart.startsWith('{') && !prevPart.endsWith('}')) {
          meaningfulPart = prevPart;
        }
        break;
      }
    }

    // 如果找不到有意义的部分，使用operationId或fallback
    if (!meaningfulPart) {
      return operation.operationId || operation.summary || 'unknownAsync';
    }

    // 组合方法名：HTTP方法 + 路径部分 + async (小驼峰命名)
    const methodLower = method.toLowerCase();
    const pathPartCapitalized = meaningfulPart.charAt(0).toUpperCase() + meaningfulPart.slice(1);

    return `${methodLower}${pathPartCapitalized}Async`;
  }
}

/**
 * 为 Vite 创建的兼容插件（为了向后兼容）
 * @param options 生成器配置选项
 * @returns Vite插件对象
 */
export function viteOpenAPIGenerator(options: OpenAPIGeneratorOptions): any {
  return {
    name: 'vite-plugin-openapi-generator',
    async buildStart() {
      await generateAPI(options);
    },
  };
}
